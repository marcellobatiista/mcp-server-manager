import os
import sys
import time
import json
import platform
import subprocess
import re
from pathlib import Path
import cli.config_util as config_util  # Importar o m√≥dulo de utilit√°rios de configura√ß√£o da pasta cli

# Configura√ß√µes padr√£o
NOME_SERVIDOR_PADRAO = "demon"
NOME_DIRETORIO_PADRAO = "mcp_server"
TOOLS_DIR = "tools"

def cabecalho(titulo):
    """Exibe um cabe√ßalho simples."""
    print(f"\n=== {titulo} ===")

def executar_comando(comando, mostrar_saida=False, shell=False):
    """Executa um comando e retorna o status de sa√≠da."""
    try:
        if mostrar_saida:
            return subprocess.call(comando, shell=shell)
        else:
            resultado = subprocess.run(comando, capture_output=True, text=True, shell=shell)
            return resultado.returncode
    except Exception as e:
        print(f"Erro ao executar comando: {e}")
        return 1

def criar_env_var(nome, valor):
    """Cria uma vari√°vel de ambiente tempor√°ria."""
    os.environ[nome] = valor

def atualizar_pip():
    """Atualiza o pip para a vers√£o mais recente."""
    cabecalho("Atualizando pip")
    executar_comando([sys.executable, "-m", "pip", "install", "--upgrade", "pip"], 
                    mostrar_saida=False)

def instalar_dependencias():
    """Instala depend√™ncias necess√°rias."""
    cabecalho("Instalando depend√™ncias")
    requirements = ["tomli>=2.0.0", "tomli-w>=1.0.0"]
    for req in requirements:
        executar_comando([sys.executable, "-m", "pip", "install", req], 
                        mostrar_saida=False)

def instalar_uv():
    """Instala o UV usando o script da pasta tools."""
    cabecalho("Instalando UV")
    
    # Vamos detectar as vers√µes do Python diretamente
    print("Detectando vers√µes do Python...")
    pythons_encontrados = []
    
    if platform.system() == "Windows":
        try:
            output = subprocess.check_output("where python", shell=True, text=True, stderr=subprocess.DEVNULL)
            paths = [p.strip() for p in output.splitlines() if "WindowsApps" not in p]
            for i, path in enumerate(paths):
                try:
                    result = subprocess.check_output([path, "--version"], text=True, stderr=subprocess.STDOUT)
                    version = result.strip()
                    # Verificar se √© Python 3.10+
                    match = re.search(r"Python (\d+)\.(\d+)", version)
                    if match:
                        major, minor = map(int, match.groups())
                        compatible = (major == 3 and minor >= 10)
                        pythons_encontrados.append((i, path, version, compatible))
                except:
                    pass
        except:
            pass
    
    # Encontrar a melhor vers√£o: primeiro compat√≠vel ou primeiro dispon√≠vel
    escolhido = None
    # Primeiro, procurar por compat√≠veis
    for idx, path, version, compatible in pythons_encontrados:
        if compatible:
            escolhido = idx
            break
    
    # Se n√£o tiver compat√≠vel, pegar o primeiro dispon√≠vel
    if escolhido is None and pythons_encontrados:
        escolhido = pythons_encontrados[0][0]
    
    # Se ainda n√£o tiver encontrado, usar o Python atual
    if escolhido is None:
        print("Nenhuma vers√£o do Python encontrada. Usando o Python atual.")
        escolhido = 0
        
    # Modificar o script para ser mais simples: criar um arquivo de resposta
    with open("python_choice.txt", "w") as f:
        f.write(f"{escolhido}\n")
    
    # Executar o script
    script_path = os.path.join(TOOLS_DIR, "instalar_uv.py")
    
    if platform.system() == "Windows":
        # Criar um batch mais simples que fornecer√° a entrada
        with open("instalar_uv_auto.bat", "w", encoding="cp1252") as f:
            f.write("@echo off\n")
            f.write(f"type python_choice.txt | {sys.executable} {script_path}\n")
        
        print(f"Instalando UV automaticamente com Python √≠ndice {escolhido}...")
        executar_comando(["instalar_uv_auto.bat"], mostrar_saida=True, shell=True)
        
        # Limpar arquivos tempor√°rios
        if os.path.exists("instalar_uv_auto.bat"):
            os.remove("instalar_uv_auto.bat")
    else:
        # No Linux/macOS
        os.system(f"cat python_choice.txt | {sys.executable} {script_path}")
    
    # Limpar arquivos tempor√°rios
    if os.path.exists("python_choice.txt"):
        os.remove("python_choice.txt")

def criar_projeto():
    """Cria o projeto MCP com nome padr√£o."""
    cabecalho("Criando projeto MCP")
    script_path = os.path.join(TOOLS_DIR, "criar_projeto_mcp.py")
    
    # Criar script tempor√°rio para resposta autom√°tica
    resposta_automatica = r"""
import sys
print("{0}")  # Nome do projeto
print("s")    # Responder 's' para sobrescrever o diret√≥rio existente
""".format(NOME_DIRETORIO_PADRAO)
    
    # Criar arquivo tempor√°rio para o script de resposta autom√°tica
    with open("temp_criar_projeto.py", "w", encoding="utf-8") as f:
        f.write(resposta_automatica)
    
    # Em Windows, usar um arquivo batch
    if platform.system() == "Windows":
        # Criar um arquivo batch tempor√°rio
        with open("temp_criar_projeto.bat", "w", encoding="cp1252") as f:
            f.write(f"@echo off\n")
            f.write(f"{sys.executable} temp_criar_projeto.py | {sys.executable} {script_path}\n")
        
        executar_comando(["temp_criar_projeto.bat"], mostrar_saida=True, shell=True)
        
        # Limpar arquivos tempor√°rios
        if os.path.exists("temp_criar_projeto.bat"):
            os.remove("temp_criar_projeto.bat")
    else:
        # No Linux/macOS podemos usar pipes diretamente
        os.system(f"{sys.executable} temp_criar_projeto.py | {sys.executable} {script_path}")
    
    # Limpar arquivos tempor√°rios
    if os.path.exists("temp_criar_projeto.py"):
        os.remove("temp_criar_projeto.py")

def ativar_ambiente():
    """Ativa o ambiente virtual e cria o servidor de teste."""
    cabecalho("Configurando ambiente")
    script_path = os.path.join(TOOLS_DIR, "ativar_ambiente.py")
    
    # Criar script para resposta autom√°tica (n√£o executar o servidor)
    resposta_automatica = "n\n"  # Responder 'n' para n√£o executar o servidor
    
    # Criar arquivo tempor√°rio para a resposta
    with open("temp_resposta.txt", "w", encoding="utf-8") as f:
        f.write(resposta_automatica)
    
    # Em Windows, usar um arquivo batch
    if platform.system() == "Windows":
        # Criar um arquivo batch tempor√°rio
        with open("temp_ativar.bat", "w", encoding="cp1252") as f:
            f.write(f"@echo off\n")
            f.write(f"type temp_resposta.txt | {sys.executable} {script_path}\n")
        
        executar_comando(["temp_ativar.bat"], mostrar_saida=True, shell=True)
        
        # Limpar arquivos tempor√°rios
        if os.path.exists("temp_ativar.bat"):
            os.remove("temp_ativar.bat")
    else:
        # No Linux/macOS podemos usar pipes diretamente
        os.system(f"cat temp_resposta.txt | {sys.executable} {script_path}")
    
    # Limpar arquivos tempor√°rios
    if os.path.exists("temp_resposta.txt"):
        os.remove("temp_resposta.txt")

def gerar_config_json():
    """Gera e mostra o config JSON para o Claude for Desktop."""
    cabecalho("CONFIGURA√á√ÉO PARA O CLAUDE FOR DESKTOP")
    
    try:
        # Ler informa√ß√µes do log
        with open("log.txt", "r", encoding="utf-8") as log_file:
            conteudo = log_file.read()
        
        # Extrair nome do projeto e caminho
        nome_match = re.search(r"Nome do Projeto: (.+)", conteudo)
        caminho_match = re.search(r"Caminho do Projeto: (.+)", conteudo)
        
        if nome_match and caminho_match:
            nome_projeto = nome_match.group(1)
            caminho_projeto = caminho_match.group(1)
            
            # Determinar o caminho do UV
            uv_path = os.path.join(os.path.expanduser("~"), "pipx", "venvs", "uv", "Scripts", "uv.exe")
            if not os.path.exists(uv_path) and platform.system() != "Windows":
                uv_path = os.path.join(os.path.expanduser("~"), ".local", "pipx", "venvs", "uv", "bin", "uv")
            if not os.path.exists(uv_path):
                uv_path = "uv"
            
            # Criar o objeto JSON - usar NOME_SERVIDOR_PADRAO para o nome do servidor
            config = {
                "mcpServers": {
                    NOME_SERVIDOR_PADRAO: {
                        "command": uv_path,
                        "args": [
                            "--directory",
                            caminho_projeto,
                            "run",
                            "demon.py"
                        ]
                    }
                }
            }
            
            # Mostrar o JSON para o usu√°rio
            print("\nCopie o JSON abaixo para o arquivo de configura√ß√£o do Claude for Desktop:")
            print(json.dumps(config, indent=4))
            
            # Mostrar onde colocar o JSON
            print("\nCaminho do arquivo de configura√ß√£o:")
            if platform.system() == "Windows":
                print("  %USERPROFILE%\\AppData\\Roaming\\Claude\\claude_desktop_config.json")
            else:
                print("  ~/Library/Application Support/Claude/claude_desktop_config.json")
            
            # Mostrar como executar o servidor manualmente
            print(f"\nPara executar o servidor: {uv_path} --directory {caminho_projeto} run demon.py")
            
            # Atualizar automaticamente os arquivos de configura√ß√£o
            print("\nüîÑ Atualizando configura√ß√µes das IDEs automaticamente...")
            
            argumentos = [
                "--directory",
                caminho_projeto,
                "run",
                "demon.py"
            ]
            
            resultado = config_util.atualizar_configuracoes(
                nome_servidor=NOME_SERVIDOR_PADRAO,
                comando=uv_path, 
                argumentos=argumentos
            )
            
            # Mostrar resultados da atualiza√ß√£o
            if resultado["cursor"]["status"] == "sucesso":
                print(f"‚úÖ Cursor: Configura√ß√£o atualizada em {resultado['cursor']['caminho']}")
            else:
                print(f"‚ùå Cursor: {resultado['cursor']['mensagem']}")
                
            if resultado["claude"]["status"] == "sucesso":
                print(f"‚úÖ Claude Desktop: Configura√ß√£o atualizada em {resultado['claude']['caminho']}")
            else:
                print(f"‚ùå Claude Desktop: {resultado['claude']['mensagem']}")
                
            print("\nüéâ Para usar o servidor, apenas reinicie o Cursor ou Claude Desktop!")
            
        else:
            print("N√£o foi poss√≠vel extrair as informa√ß√µes do log.txt")
    
    except Exception as e:
        print(f"Erro ao gerar configura√ß√£o: {e}")

def criar_servidor_teste(nome_projeto, caminho_projeto):
    """Cria um arquivo de servidor MCP para teste."""
    cabecalho("Criando servidor MCP de teste")
    
    # Determinar o caminho do UV
    uv_path = os.path.join(os.path.expanduser("~"), "pipx", "venvs", "uv", "Scripts", "uv.exe")
    if not os.path.exists(uv_path) and platform.system() != "Windows":
        uv_path = os.path.join(os.path.expanduser("~"), ".local", "pipx", "venvs", "uv", "bin", "uv")
    if not os.path.exists(uv_path):
        uv_path = "uv"
    
    print(f"‚úÖ Usando uv de: {uv_path}")
    
    # Conte√∫do do servidor MCP b√°sico - usar NOME_SERVIDOR_PADRAO para o nome do servidor
    conteudo_servidor = f'''#!/usr/bin/env python3
# Servidor MCP de teste para o projeto {NOME_SERVIDOR_PADRAO}
# Criado automaticamente por quick_setup.py

import os
from mcp.server.fastmcp import FastMCP

# Criar inst√¢ncia do servidor MCP
mcp = FastMCP(
    name="{NOME_SERVIDOR_PADRAO}",
    description="Servidor MCP b√°sico para testes"
)

def ler_log():
    """Fun√ß√£o interna para ler o arquivo log.txt."""
    try:
        # Tenta encontrar o log.txt um n√≠vel acima
        log_path = os.path.join(os.path.dirname(os.path.dirname(os.getcwd())), "log.txt")
        if os.path.exists(log_path):
            with open(log_path, "r", encoding="utf-8") as f:
                return f.read()
        return "Arquivo log.txt n√£o encontrado"
    except Exception as e:
        return f"Erro ao ler log.txt: {{e}}"

@mcp.tool()
def hello(name: str = "World") -> str:
    """Retorna uma sauda√ß√£o simples.
    
    Args:
        name: O nome para saudar. Padr√£o: "World"
        
    Returns:
        Uma mensagem de sauda√ß√£o
    """
    return f"Hello {{name}} from MCP!"

@mcp.tool()
def add(a: float, b: float) -> float:
    """Soma dois n√∫meros.
    
    Args:
        a: Primeiro n√∫mero
        b: Segundo n√∫mero
        
    Returns:
        A soma dos dois n√∫meros
    """
    return a + b

@mcp.tool()
def config_info() -> str:
    """Retorna informa√ß√µes de configura√ß√£o do servidor.
    
    Returns:
        Uma string com informa√ß√µes sobre o servidor e o projeto
    """
    diretorio_atual = os.getcwd()
    conteudo_log = ler_log()
    
    return f"""
=== INFORMA√á√ïES DO SERVIDOR MCP ===
Nome do servidor: {NOME_SERVIDOR_PADRAO}
Diret√≥rio: {{diretorio_atual}}

=== LOG DE INSTALA√á√ÉO ===
{{conteudo_log}}

=== STATUS ===
Servidor em execu√ß√£o: Sim
"""

if __name__ == "__main__":
    print(f"Iniciando servidor MCP: {NOME_SERVIDOR_PADRAO}")
    print("Voc√™ pode usar as seguintes ferramentas:")
    print("  - hello: Retorna uma sauda√ß√£o simples")
    print("  - add: Soma dois n√∫meros")
    print("  - config_info: Retorna informa√ß√µes de configura√ß√£o")
    mcp.run(transport='stdio')
'''
    
    caminho_arquivo = os.path.join(caminho_projeto, "demon.py")
    
    try:
        with open(caminho_arquivo, "w", encoding="utf-8") as f:
            f.write(conteudo_servidor)
        print(f"Servidor MCP de teste criado com sucesso: demon.py")
        print("Para executar o servidor, use:")
        print(f"  {uv_path} --directory {caminho_projeto} run demon.py")
        return True
    except Exception as e:
        print(f"Erro ao criar o servidor de teste: {e}")
        return False

def ir_para_launcher():
    """Executa o script launcher.py para come√ßar a gerenciar os servidores."""
    cabecalho("INICIANDO LAUNCHER")
    
    print("\nüöÄ Iniciando o launcher MCP para gerenciar seus servidores...")
    
    try:
        # Executa o launcher.py no novo caminho
        script_path = os.path.join("cli", "launcher.py")
        if os.path.exists(script_path):
            executar_comando([sys.executable, script_path], mostrar_saida=True)
        else:
            print(f"‚ùå Erro: N√£o foi poss√≠vel encontrar o launcher em {script_path}")
    except Exception as e:
        print(f"‚ùå Erro ao iniciar o launcher: {e}")

def main():
    """Fun√ß√£o principal do script de setup r√°pido."""
    cabecalho("CONFIGURA√á√ÉO R√ÅPIDA DO SERVIDOR MCP")
    
    print("Este script vai configurar rapidamente o ambiente para os servidores MCP.")
    print("Ele ir√° realizar as seguintes opera√ß√µes:")
    print("  1. Atualizar o pip")
    print("  2. Instalar depend√™ncias necess√°rias")
    print("  3. Instalar o gerenciador UV")
    print("  4. Criar o projeto MCP b√°sico")
    print("  5. Ativar o ambiente virtual")
    print("  6. Iniciar o launcher para gerenciar servidores")
    
    continuar = input("\nDeseja continuar? (s/n): ")
    if continuar.lower() != 's':
        print("\nOpera√ß√£o cancelada pelo usu√°rio.")
        sys.exit(0)
    
    # Atualizar o pip
    atualizar_pip()
    
    # Instalar depend√™ncias
    instalar_dependencias()
    
    # Instalar o UV
    instalar_uv()
    
    # Criar o projeto MCP
    criar_projeto()
    
    # Ativar ambiente e criar servidor teste
    ativar_ambiente()
    
    # Criar arquivo .bat para executar o launcher
    criar_launcher_bat()
    
    print("\n‚úÖ Configura√ß√£o r√°pida conclu√≠da com sucesso!")
    print("Agora voc√™ pode executar o launcher para gerenciar seus servidores.")
    
    iniciar_launcher = input("\nDeseja iniciar o launcher agora? (s/n): ")
    if iniciar_launcher.lower() == 's':
        ir_para_launcher()
    else:
        print("\nVoc√™ pode iniciar o launcher a qualquer momento executando:")
        print(f"  python {os.path.join('cli', 'launcher.py')}")
        print("Ou usando o atalho 'launcher.bat' criado na pasta do projeto.")

def criar_launcher_bat():
    """Cria um arquivo batch para facilitar a execu√ß√£o do launcher."""
    try:
        # Criar arquivo launcher.bat
        with open("launcher.bat", "w", encoding="cp1252") as f:
            f.write(f"@echo off\n")
            f.write("echo Iniciando MCP Launcher...\n")
            f.write(f"{sys.executable} {os.path.join('cli', 'launcher.py')}\n")
        
        print("‚úÖ Criado arquivo 'launcher.bat' para execu√ß√£o r√°pida")
    except Exception as e:
        print(f"‚ùå Erro ao criar arquivo launcher.bat: {e}")
        
if __name__ == "__main__":
    main() 